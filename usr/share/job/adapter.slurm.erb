# ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
#  >>>> FLIGHT JOB ADAPTER
# ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

#======================
#  Controls directory
#----------------------
# The controls directory is used internally to track various flight-job data
# files.  This is used to store the desktop session ID of the interactive
# session.
if [ "${CONTROLS_DIR}" != "" ]; then
  mkdir -p "${CONTROLS_DIR}"
fi

register_control() {
  local name
  local value
  name="$1"
  if [[ -p /dev/stdin ]]; then
      value="$( cat - )"
  else
      value="$2"
  fi
  if [ -d "${CONTROLS_DIR}" ]; then
    echo "${value}" > "${CONTROLS_DIR}/${name}"
  else
    echo "CONTROLS_DIR has not been set or is not a directory" >&2
    echo "${name} ${value}"
  fi
}

<% if template.tag('script:type') == 'interactive' -%>
<% if template.tag('session:host') == 'login' -%>
#=========================
#  Session orchestration
#-------------------------
# Functions used to orchestrate the creation of your interactive session on a
# login node with X11 forwarding to a compute node.
# XXX RESULTS_DIR might not be set yet.  Or could be wrong.
SESSION_OUTPUT="${RESULTS_DIR}/session.output"

on_login_host() {
    [ -z $SLURM_JOBID ]
}

prepare_x11_forwarding() {
    # Add our short hostname to the DISPLAY variable if we need to
    if [ `echo $DISPLAY | cut -d: -f1 | egrep -c [a-z]` -lt 1 ] ; then
        export DISPLAYNAME=`hostname -s`$DISPLAY
    else
        export DISPLAYNAME=$DISPLAY
    fi
}

register_scheduler_id() {
    stdbuf -oL sed -n 's/.*job \([0-9]*\) queued.*/\1/p' \
        | head -n 1 \
        | register_control "scheduler_id" 
}

request_allocation() {
    # Request a slurm command-line session with any supplied variables, and
    # run this job script on the allocation.
    echo srun --pty "$@" "${BASH_SOURCE[0]}" $DISPLAYNAME
    local submit_status
    register_control "job_type" "BOOTSTRAPPING"
    register_control "submit_status" "0"
    srun --pty "$@" "${BASH_SOURCE[0]}" $DISPLAYNAME \
        2> >( tee >( register_scheduler_id ) )
    submit_status=$?
    if [[ $submit_status -ne 0 ]] ; then
        register_control "submit_status" $submit_status
        register_control "job_type" "FAILED_SUBMISSION"
        register_control "submit_stderr" "srun failed to submit job"
    else
        echo "Scheduler allocation has completed. Exiting..."
        sleep 2
    fi
}

configure_x11_forwarding() {
    # Setup the originator to expect our X connection.
    DISPLAYNAME=$1
    DISPLAYHOST=`echo $DISPLAYNAME | cut -d: -f1`
    this_hostname=`hostname -s`
    setxhost="ssh $DISPLAYHOST 'export DISPLAY=$DISPLAYNAME && xhost $this_hostname'"
    echo -ne "Enabling $DISPLAYHOST to accept our X-connection... "
    eval $setxhost
    export DISPLAY=$DISPLAYNAME
}

flight_job_book_keeping() {
    register_control "scheduler_id" "$SLURM_JOB_ID"
    register_control "job_type" "BOOTSTRAPPING"
}

<% else -%>
#=========================
#  Session orchestration
#-------------------------
# Functions used to orchestrate the creation of your interactive session on a
# compute node with Flight Desktop.
FLIGHT_SESSION_ID_PATH="${CONTROLS_DIR}"/flight_desktop_id
FLIGHT_SESSION_STATUS_PATH="${CONTROLS_DIR}"/flight_desktop_status
# XXX RESULTS_DIR might not be set yet.  Or could be wrong.
SESSION_OUTPUT="${RESULTS_DIR}/session.output"

create_session_script() {
    SESSION_SCRIPT=$( mktemp --tmpdir session-script.XXXXXX.sh )
    echo "Creating session script ${SESSION_SCRIPT}"
    export SESSION_SCRIPT
    cat > ${SESSION_SCRIPT}
    chmod +x ${SESSION_SCRIPT}
}

session_run() {
    session_start
    session_await
}

session_start() {
    if [ "${SESSION_SCRIPT}" == "" ] ; then
        echo "Session script not created. Aborting." >&2
        exit 1
    fi
    echo "Starting session..."
    (
        set -o pipefail
        ${flight_ROOT:-/opt/flight}/bin/flight desktop \
            start \
            --script ${SESSION_SCRIPT} \
            --no-override-env \
            | tee >( grep '^Identity' | cut -f2 > "${FLIGHT_SESSION_ID_PATH}" )
    )

    SESSION_STARTED=$?
    echo ${SESSION_STARTED} > "$FLIGHT_SESSION_STATUS_PATH"
}

session_is_active() {
    local state
    state=$(
        ${flight_ROOT:-/opt/flight}/bin/flight desktop \
            show "${SESSION_ID}" 2>/dev/null \
            | grep '^State' \
            | cut -d $'\t' -f 2
    )
    [ "${state}" == "Active" ]
}

session_await() {
    if [ ${SESSION_STARTED} -ne 0 ] ; then
        echo "Session failed to start. Aborting." >&2
        exit 1
    fi
    SESSION_ID=$(cat "${FLIGHT_SESSION_ID_PATH}")
    SESSION_ID=${SESSION_ID##[[:space:]]}
    SESSION_ID=${SESSION_ID%%[[:space:]]}
    if [ "${SESSION_ID}" == "" ] ; then
        echo "Unable to determine session ID. Aborting." >&2
        exit 1
    fi
    echo "Session ID is ${SESSION_ID}" 
    echo "Waiting for session to end..." 
    while session_is_active ; do
        sleep 60
    done
    echo "Session is no longer running."
}
<% end -%>
<% end -%>
